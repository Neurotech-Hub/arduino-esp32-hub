# ESP32 Hub Patch for libraries/BLE/src/BLECharacteristic.cpp
# Generated: 2024-12-14 14:47:59.866235
# Purpose: Fix BLE memory leaks.
#
--- original/libraries/BLE/src/BLECharacteristic.cpp	2024-12-14 14:46:17
+++ modified/libraries/BLE/src/BLECharacteristic.cpp	2024-12-13 19:03:11
@@ -25,7 +25,7 @@
 
 #define NULL_HANDLE (0xffff)
 
-static BLECharacteristicCallbacks defaultCallback;  //null-object-pattern
+static BLECharacteristicCallbacks defaultCallback; // null-object-pattern
 
 /**
  * @brief Construct a characteristic
@@ -39,7 +39,8 @@
  * @param [in] uuid - UUID for the characteristic.
  * @param [in] properties - Properties for the characteristic.
  */
-BLECharacteristic::BLECharacteristic(BLEUUID uuid, uint32_t properties) {
+BLECharacteristic::BLECharacteristic(BLEUUID uuid, uint32_t properties)
+{
   m_bleUUID = uuid;
   m_handle = NULL_HANDLE;
   m_properties = (esp_gatt_char_prop_t)0;
@@ -51,39 +52,58 @@
   setNotifyProperty((properties & PROPERTY_NOTIFY) != 0);
   setIndicateProperty((properties & PROPERTY_INDICATE) != 0);
   setWriteNoResponseProperty((properties & PROPERTY_WRITE_NR) != 0);
-}  // BLECharacteristic
+} // BLECharacteristic
 
 /**
  * @brief Destructor.
  */
-BLECharacteristic::~BLECharacteristic() {
-  //free(m_value.attr_value); // Release the storage for the value.
-}  // ~BLECharacteristic
+BLECharacteristic::~BLECharacteristic()
+{
+  log_v(">> ~BLECharacteristic: %s", toString().c_str());
 
+  // Clean up all descriptors
+  BLEDescriptor *pDescriptor = m_descriptorMap.getFirst();
+  while (pDescriptor != nullptr)
+  {
+    BLEDescriptor *pNext = m_descriptorMap.getNext();
+    if (pDescriptor)
+    {
+      log_v("Deleting descriptor: %s", pDescriptor->toString().c_str());
+      delete pDescriptor;
+    }
+    pDescriptor = pNext;
+  }
+
+  log_v("<< ~BLECharacteristic");
+} // ~BLECharacteristic
+
 /**
  * @brief Associate a descriptor with this characteristic.
  * @param [in] pDescriptor
  * @return N/A.
  */
-void BLECharacteristic::addDescriptor(BLEDescriptor *pDescriptor) {
+void BLECharacteristic::addDescriptor(BLEDescriptor *pDescriptor)
+{
   log_v(">> addDescriptor(): Adding %s to %s", pDescriptor->toString().c_str(), toString().c_str());
   m_descriptorMap.setByUUID(pDescriptor->getUUID(), pDescriptor);
   log_v("<< addDescriptor()");
-}  // addDescriptor
+} // addDescriptor
 
 /**
  * @brief Register a new characteristic with the ESP runtime.
  * @param [in] pService The service with which to associate this characteristic.
  */
-void BLECharacteristic::executeCreate(BLEService *pService) {
+void BLECharacteristic::executeCreate(BLEService *pService)
+{
   log_v(">> executeCreate()");
 
-  if (m_handle != NULL_HANDLE) {
+  if (m_handle != NULL_HANDLE)
+  {
     log_e("Characteristic already has a handle.");
     return;
   }
 
-  m_pService = pService;  // Save the service to which this characteristic belongs.
+  m_pService = pService; // Save the service to which this characteristic belongs.
 
   log_d("Registering characteristic (esp_ble_gatts_add_char): uuid: %s, service: %s", getUUID().toString().c_str(), m_pService->toString().c_str());
 
@@ -92,357 +112,395 @@
 
   m_semaphoreCreateEvt.take("executeCreate");
   esp_err_t errRc = ::esp_ble_gatts_add_char(
-    m_pService->getHandle(), getUUID().getNative(), static_cast<esp_gatt_perm_t>(m_permissions), getProperties(), nullptr,
-    &control
-  );  // Whether to auto respond or not.
+      m_pService->getHandle(), getUUID().getNative(), static_cast<esp_gatt_perm_t>(m_permissions), getProperties(), nullptr,
+      &control); // Whether to auto respond or not.
 
-  if (errRc != ESP_OK) {
+  if (errRc != ESP_OK)
+  {
     log_e("<< esp_ble_gatts_add_char: rc=%d %s", errRc, GeneralUtils::errorToString(errRc));
     return;
   }
   m_semaphoreCreateEvt.wait("executeCreate");
 
   BLEDescriptor *pDescriptor = m_descriptorMap.getFirst();
-  while (pDescriptor != nullptr) {
+  while (pDescriptor != nullptr)
+  {
     pDescriptor->executeCreate(this);
     pDescriptor = m_descriptorMap.getNext();
-  }  // End while
+  } // End while
 
   log_v("<< executeCreate");
-}  // executeCreate
+} // executeCreate
 
 /**
  * @brief Return the BLE Descriptor for the given UUID if associated with this characteristic.
  * @param [in] descriptorUUID The UUID of the descriptor that we wish to retrieve.
  * @return The BLE Descriptor.  If no such descriptor is associated with the characteristic, nullptr is returned.
  */
-BLEDescriptor *BLECharacteristic::getDescriptorByUUID(const char *descriptorUUID) {
+BLEDescriptor *BLECharacteristic::getDescriptorByUUID(const char *descriptorUUID)
+{
   return m_descriptorMap.getByUUID(BLEUUID(descriptorUUID));
-}  // getDescriptorByUUID
+} // getDescriptorByUUID
 
 /**
  * @brief Return the BLE Descriptor for the given UUID if associated with this characteristic.
  * @param [in] descriptorUUID The UUID of the descriptor that we wish to retrieve.
  * @return The BLE Descriptor.  If no such descriptor is associated with the characteristic, nullptr is returned.
  */
-BLEDescriptor *BLECharacteristic::getDescriptorByUUID(BLEUUID descriptorUUID) {
+BLEDescriptor *BLECharacteristic::getDescriptorByUUID(BLEUUID descriptorUUID)
+{
   return m_descriptorMap.getByUUID(descriptorUUID);
-}  // getDescriptorByUUID
+} // getDescriptorByUUID
 
 /**
  * @brief Get the handle of the characteristic.
  * @return The handle of the characteristic.
  */
-uint16_t BLECharacteristic::getHandle() {
+uint16_t BLECharacteristic::getHandle()
+{
   return m_handle;
-}  // getHandle
+} // getHandle
 
-void BLECharacteristic::setAccessPermissions(esp_gatt_perm_t perm) {
+void BLECharacteristic::setAccessPermissions(esp_gatt_perm_t perm)
+{
   m_permissions = perm;
 }
 
-esp_gatt_char_prop_t BLECharacteristic::getProperties() {
+esp_gatt_char_prop_t BLECharacteristic::getProperties()
+{
   return m_properties;
-}  // getProperties
+} // getProperties
 
 /**
  * @brief Get the service associated with this characteristic.
  */
-BLEService *BLECharacteristic::getService() {
+BLEService *BLECharacteristic::getService()
+{
   return m_pService;
-}  // getService
+} // getService
 
 /**
  * @brief Get the UUID of the characteristic.
  * @return The UUID of the characteristic.
  */
-BLEUUID BLECharacteristic::getUUID() {
+BLEUUID BLECharacteristic::getUUID()
+{
   return m_bleUUID;
-}  // getUUID
+} // getUUID
 
 /**
  * @brief Retrieve the current value of the characteristic.
  * @return A pointer to storage containing the current characteristic value.
  */
-String BLECharacteristic::getValue() {
+String BLECharacteristic::getValue()
+{
   return m_value.getValue();
-}  // getValue
+} // getValue
 
 /**
  * @brief Retrieve the current raw data of the characteristic.
  * @return A pointer to storage containing the current characteristic data.
  */
-uint8_t *BLECharacteristic::getData() {
+uint8_t *BLECharacteristic::getData()
+{
   return m_value.getData();
-}  // getData
+} // getData
 
 /**
  * @brief Retrieve the current length of the data of the characteristic.
  * @return Amount of databytes of the characteristic.
  */
-size_t BLECharacteristic::getLength() {
+size_t BLECharacteristic::getLength()
+{
   return m_value.getLength();
-}  // getLength
+} // getLength
 
 /**
  * Handle a GATT server event.
  */
-void BLECharacteristic::handleGATTServerEvent(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param) {
+void BLECharacteristic::handleGATTServerEvent(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param)
+{
   log_v(">> handleGATTServerEvent: %s", BLEUtils::gattServerEventTypeToString(event).c_str());
 
-  switch (event) {
-      // Events handled:
-      //
-      // ESP_GATTS_ADD_CHAR_EVT
-      // ESP_GATTS_CONF_EVT
-      // ESP_GATTS_CONNECT_EVT
-      // ESP_GATTS_DISCONNECT_EVT
-      // ESP_GATTS_EXEC_WRITE_EVT
-      // ESP_GATTS_READ_EVT
-      // ESP_GATTS_WRITE_EVT
-
+  switch (event)
+  {
+    // Events handled:
     //
+    // ESP_GATTS_ADD_CHAR_EVT
+    // ESP_GATTS_CONF_EVT
+    // ESP_GATTS_CONNECT_EVT
+    // ESP_GATTS_DISCONNECT_EVT
     // ESP_GATTS_EXEC_WRITE_EVT
-    // When we receive this event it is an indication that a previous write long needs to be committed.
-    //
-    // exec_write:
-    // - uint16_t conn_id
-    // - uint32_t trans_id
-    // - esp_bd_addr_t bda
-    // - uint8_t exec_write_flag - Either ESP_GATT_PREP_WRITE_EXEC or ESP_GATT_PREP_WRITE_CANCEL
-    //
-    case ESP_GATTS_EXEC_WRITE_EVT:
+    // ESP_GATTS_READ_EVT
+    // ESP_GATTS_WRITE_EVT
+
+  //
+  // ESP_GATTS_EXEC_WRITE_EVT
+  // When we receive this event it is an indication that a previous write long needs to be committed.
+  //
+  // exec_write:
+  // - uint16_t conn_id
+  // - uint32_t trans_id
+  // - esp_bd_addr_t bda
+  // - uint8_t exec_write_flag - Either ESP_GATT_PREP_WRITE_EXEC or ESP_GATT_PREP_WRITE_CANCEL
+  //
+  case ESP_GATTS_EXEC_WRITE_EVT:
+  {
+    if (m_writeEvt)
     {
-      if (m_writeEvt) {
-        m_writeEvt = false;
-        if (param->exec_write.exec_write_flag == ESP_GATT_PREP_WRITE_EXEC) {
-          m_value.commit();
-          // Invoke the onWrite callback handler.
-          m_pCallbacks->onWrite(this, param);
-        } else {
-          m_value.cancel();
-        }
-        // ???
-        esp_err_t errRc = ::esp_ble_gatts_send_response(gatts_if, param->write.conn_id, param->write.trans_id, ESP_GATT_OK, nullptr);
-        if (errRc != ESP_OK) {
-          log_e("esp_ble_gatts_send_response: rc=%d %s", errRc, GeneralUtils::errorToString(errRc));
-        }
+      m_writeEvt = false;
+      if (param->exec_write.exec_write_flag == ESP_GATT_PREP_WRITE_EXEC)
+      {
+        m_value.commit();
+        // Invoke the onWrite callback handler.
+        m_pCallbacks->onWrite(this, param);
       }
-      break;
-    }  // ESP_GATTS_EXEC_WRITE_EVT
+      else
+      {
+        m_value.cancel();
+      }
+      // ???
+      esp_err_t errRc = ::esp_ble_gatts_send_response(gatts_if, param->write.conn_id, param->write.trans_id, ESP_GATT_OK, nullptr);
+      if (errRc != ESP_OK)
+      {
+        log_e("esp_ble_gatts_send_response: rc=%d %s", errRc, GeneralUtils::errorToString(errRc));
+      }
+    }
+    break;
+  } // ESP_GATTS_EXEC_WRITE_EVT
 
-    // ESP_GATTS_ADD_CHAR_EVT - Indicate that a characteristic was added to the service.
-    // add_char:
-    // - esp_gatt_status_t status
-    // - uint16_t attr_handle
-    // - uint16_t service_handle
-    // - esp_bt_uuid_t char_uuid
-    case ESP_GATTS_ADD_CHAR_EVT:
+  // ESP_GATTS_ADD_CHAR_EVT - Indicate that a characteristic was added to the service.
+  // add_char:
+  // - esp_gatt_status_t status
+  // - uint16_t attr_handle
+  // - uint16_t service_handle
+  // - esp_bt_uuid_t char_uuid
+  case ESP_GATTS_ADD_CHAR_EVT:
+  {
+    if (getHandle() == param->add_char.attr_handle)
     {
-      if (getHandle() == param->add_char.attr_handle) {
-        // we have created characteristic, now we can create descriptors
-        // BLEDescriptor* pDescriptor = m_descriptorMap.getFirst();
-        // while (pDescriptor != nullptr) {
-        // 	pDescriptor->executeCreate(this);
-        // 	pDescriptor = m_descriptorMap.getNext();
-        // } // End while
-        m_semaphoreCreateEvt.give();
-      }
-      break;
-    }  // ESP_GATTS_ADD_CHAR_EVT
+      // we have created characteristic, now we can create descriptors
+      // BLEDescriptor* pDescriptor = m_descriptorMap.getFirst();
+      // while (pDescriptor != nullptr) {
+      // 	pDescriptor->executeCreate(this);
+      // 	pDescriptor = m_descriptorMap.getNext();
+      // } // End while
+      m_semaphoreCreateEvt.give();
+    }
+    break;
+  } // ESP_GATTS_ADD_CHAR_EVT
 
-    // ESP_GATTS_WRITE_EVT - A request to write the value of a characteristic has arrived.
-    //
-    // write:
-    // - uint16_t      conn_id
-    // - uint16_t      trans_id
-    // - esp_bd_addr_t bda
-    // - uint16_t      handle
-    // - uint16_t      offset
-    // - bool          need_rsp
-    // - bool          is_prep
-    // - uint16_t      len
-    // - uint8_t      *value
-    //
-    case ESP_GATTS_WRITE_EVT:
+  // ESP_GATTS_WRITE_EVT - A request to write the value of a characteristic has arrived.
+  //
+  // write:
+  // - uint16_t      conn_id
+  // - uint16_t      trans_id
+  // - esp_bd_addr_t bda
+  // - uint16_t      handle
+  // - uint16_t      offset
+  // - bool          need_rsp
+  // - bool          is_prep
+  // - uint16_t      len
+  // - uint8_t      *value
+  //
+  case ESP_GATTS_WRITE_EVT:
+  {
+    // We check if this write request is for us by comparing the handles in the event.  If it is for us
+    // we save the new value.  Next we look at the need_rsp flag which indicates whether or not we need
+    // to send a response.  If we do, then we formulate a response and send it.
+    if (param->write.handle == m_handle)
     {
-      // We check if this write request is for us by comparing the handles in the event.  If it is for us
-      // we save the new value.  Next we look at the need_rsp flag which indicates whether or not we need
-      // to send a response.  If we do, then we formulate a response and send it.
-      if (param->write.handle == m_handle) {
-        if (param->write.is_prep) {
-          m_value.addPart(param->write.value, param->write.len);
-          m_writeEvt = true;
-        } else {
-          setValue(param->write.value, param->write.len);
-        }
+      if (param->write.is_prep)
+      {
+        m_value.addPart(param->write.value, param->write.len);
+        m_writeEvt = true;
+      }
+      else
+      {
+        setValue(param->write.value, param->write.len);
+      }
 
-        log_d(" - Response to write event: New value: handle: %.2x, uuid: %s", getHandle(), getUUID().toString().c_str());
+      log_d(" - Response to write event: New value: handle: %.2x, uuid: %s", getHandle(), getUUID().toString().c_str());
 
-        char *pHexData = BLEUtils::buildHexData(nullptr, param->write.value, param->write.len);
-        log_d(" - Data: length: %d, data: %s", param->write.len, pHexData);
-        free(pHexData);
+      char *pHexData = BLEUtils::buildHexData(nullptr, param->write.value, param->write.len);
+      log_d(" - Data: length: %d, data: %s", param->write.len, pHexData);
+      free(pHexData);
 
-        if (param->write.need_rsp) {
-          esp_gatt_rsp_t rsp;
+      if (param->write.need_rsp)
+      {
+        esp_gatt_rsp_t rsp;
 
-          rsp.attr_value.len = param->write.len;
-          rsp.attr_value.handle = m_handle;
-          rsp.attr_value.offset = param->write.offset;
-          rsp.attr_value.auth_req = ESP_GATT_AUTH_REQ_NONE;
-          memcpy(rsp.attr_value.value, param->write.value, param->write.len);
+        rsp.attr_value.len = param->write.len;
+        rsp.attr_value.handle = m_handle;
+        rsp.attr_value.offset = param->write.offset;
+        rsp.attr_value.auth_req = ESP_GATT_AUTH_REQ_NONE;
+        memcpy(rsp.attr_value.value, param->write.value, param->write.len);
 
-          esp_err_t errRc = ::esp_ble_gatts_send_response(gatts_if, param->write.conn_id, param->write.trans_id, ESP_GATT_OK, &rsp);
-          if (errRc != ESP_OK) {
-            log_e("esp_ble_gatts_send_response: rc=%d %s", errRc, GeneralUtils::errorToString(errRc));
-          }
-        }  // Response needed
-
-        if (param->write.is_prep != true) {
-          // Invoke the onWrite callback handler.
-          m_pCallbacks->onWrite(this, param);
+        esp_err_t errRc = ::esp_ble_gatts_send_response(gatts_if, param->write.conn_id, param->write.trans_id, ESP_GATT_OK, &rsp);
+        if (errRc != ESP_OK)
+        {
+          log_e("esp_ble_gatts_send_response: rc=%d %s", errRc, GeneralUtils::errorToString(errRc));
         }
-      }  // Match on handles.
-      break;
-    }  // ESP_GATTS_WRITE_EVT
+      } // Response needed
 
-    // ESP_GATTS_READ_EVT - A request to read the value of a characteristic has arrived.
-    //
-    // read:
-    // - uint16_t      conn_id
-    // - uint32_t      trans_id
-    // - esp_bd_addr_t bda
-    // - uint16_t      handle
-    // - uint16_t      offset
-    // - bool          is_long
-    // - bool          need_rsp
-    //
-    case ESP_GATTS_READ_EVT:
+      if (param->write.is_prep != true)
+      {
+        // Invoke the onWrite callback handler.
+        m_pCallbacks->onWrite(this, param);
+      }
+    } // Match on handles.
+    break;
+  } // ESP_GATTS_WRITE_EVT
+
+  // ESP_GATTS_READ_EVT - A request to read the value of a characteristic has arrived.
+  //
+  // read:
+  // - uint16_t      conn_id
+  // - uint32_t      trans_id
+  // - esp_bd_addr_t bda
+  // - uint16_t      handle
+  // - uint16_t      offset
+  // - bool          is_long
+  // - bool          need_rsp
+  //
+  case ESP_GATTS_READ_EVT:
+  {
+    if (param->read.handle == m_handle)
     {
-      if (param->read.handle == m_handle) {
 
-        // Here's an interesting thing.  The read request has the option of saying whether we need a response
-        // or not.  What would it "mean" to receive a read request and NOT send a response back?  That feels like
-        // a very strange read.
-        //
-        // We have to handle the case where the data we wish to send back to the client is greater than the maximum
-        // packet size of 22 bytes.  In this case, we become responsible for chunking the data into units of 22 bytes.
-        // The apparent algorithm is as follows:
-        //
-        // If the is_long flag is set then this is a follow on from an original read and we will already have sent at least 22 bytes.
-        // If the is_long flag is not set then we need to check how much data we are going to send.  If we are sending LESS than
-        // 22 bytes, then we "just" send it and that's the end of the story.
-        // If we are sending 22 bytes exactly, we just send it BUT we will get a follow on request.
-        // If we are sending more than 22 bytes, we send the first 22 bytes and we will get a follow on request.
-        // Because of follow on request processing, we need to maintain an offset of how much data we have already sent
-        // so that when a follow on request arrives, we know where to start in the data to send the next sequence.
-        // Note that the indication that the client will send a follow on request is that we sent exactly 22 bytes as a response.
-        // If our payload is divisible by 22 then the last response will be a response of 0 bytes in length.
-        //
-        // The following code has deliberately not been factored to make it fewer statements because this would cloud the
-        // the logic flow comprehension.
-        //
+      // Here's an interesting thing.  The read request has the option of saying whether we need a response
+      // or not.  What would it "mean" to receive a read request and NOT send a response back?  That feels like
+      // a very strange read.
+      //
+      // We have to handle the case where the data we wish to send back to the client is greater than the maximum
+      // packet size of 22 bytes.  In this case, we become responsible for chunking the data into units of 22 bytes.
+      // The apparent algorithm is as follows:
+      //
+      // If the is_long flag is set then this is a follow on from an original read and we will already have sent at least 22 bytes.
+      // If the is_long flag is not set then we need to check how much data we are going to send.  If we are sending LESS than
+      // 22 bytes, then we "just" send it and that's the end of the story.
+      // If we are sending 22 bytes exactly, we just send it BUT we will get a follow on request.
+      // If we are sending more than 22 bytes, we send the first 22 bytes and we will get a follow on request.
+      // Because of follow on request processing, we need to maintain an offset of how much data we have already sent
+      // so that when a follow on request arrives, we know where to start in the data to send the next sequence.
+      // Note that the indication that the client will send a follow on request is that we sent exactly 22 bytes as a response.
+      // If our payload is divisible by 22 then the last response will be a response of 0 bytes in length.
+      //
+      // The following code has deliberately not been factored to make it fewer statements because this would cloud the
+      // the logic flow comprehension.
+      //
 
-        // get mtu for peer device that we are sending read request to
-        uint16_t maxOffset = getService()->getServer()->getPeerMTU(param->read.conn_id) - 1;
-        log_d("mtu value: %d", maxOffset);
-        if (param->read.need_rsp) {
-          log_d("Sending a response (esp_ble_gatts_send_response)");
-          esp_gatt_rsp_t rsp;
+      // get mtu for peer device that we are sending read request to
+      uint16_t maxOffset = getService()->getServer()->getPeerMTU(param->read.conn_id) - 1;
+      log_d("mtu value: %d", maxOffset);
+      if (param->read.need_rsp)
+      {
+        log_d("Sending a response (esp_ble_gatts_send_response)");
+        esp_gatt_rsp_t rsp;
 
-          if (param->read.is_long) {
-            String value = m_value.getValue();
+        if (param->read.is_long)
+        {
+          String value = m_value.getValue();
 
-            if (value.length() - m_value.getReadOffset() < maxOffset) {
-              // This is the last in the chain
-              rsp.attr_value.len = value.length() - m_value.getReadOffset();
-              rsp.attr_value.offset = m_value.getReadOffset();
-              memcpy(rsp.attr_value.value, value.c_str() + rsp.attr_value.offset, rsp.attr_value.len);
-              m_value.setReadOffset(0);
-            } else {
-              // There will be more to come.
-              rsp.attr_value.len = maxOffset;
-              rsp.attr_value.offset = m_value.getReadOffset();
-              memcpy(rsp.attr_value.value, value.c_str() + rsp.attr_value.offset, rsp.attr_value.len);
-              m_value.setReadOffset(rsp.attr_value.offset + maxOffset);
-            }
-          } else {  // read.is_long == false
+          if (value.length() - m_value.getReadOffset() < maxOffset)
+          {
+            // This is the last in the chain
+            rsp.attr_value.len = value.length() - m_value.getReadOffset();
+            rsp.attr_value.offset = m_value.getReadOffset();
+            memcpy(rsp.attr_value.value, value.c_str() + rsp.attr_value.offset, rsp.attr_value.len);
+            m_value.setReadOffset(0);
+          }
+          else
+          {
+            // There will be more to come.
+            rsp.attr_value.len = maxOffset;
+            rsp.attr_value.offset = m_value.getReadOffset();
+            memcpy(rsp.attr_value.value, value.c_str() + rsp.attr_value.offset, rsp.attr_value.len);
+            m_value.setReadOffset(rsp.attr_value.offset + maxOffset);
+          }
+        }
+        else
+        { // read.is_long == false
 
-            // If is.long is false then this is the first (or only) request to read data, so invoke the callback
-            // Invoke the read callback.
-            m_pCallbacks->onRead(this, param);
+          // If is.long is false then this is the first (or only) request to read data, so invoke the callback
+          // Invoke the read callback.
+          m_pCallbacks->onRead(this, param);
 
-            String value = m_value.getValue();
+          String value = m_value.getValue();
 
-            if (value.length() + 1 > maxOffset) {
-              // Too big for a single shot entry.
-              m_value.setReadOffset(maxOffset);
-              rsp.attr_value.len = maxOffset;
-              rsp.attr_value.offset = 0;
-              memcpy(rsp.attr_value.value, value.c_str(), rsp.attr_value.len);
-            } else {
-              // Will fit in a single packet with no callbacks required.
-              rsp.attr_value.len = value.length();
-              rsp.attr_value.offset = 0;
-              memcpy(rsp.attr_value.value, value.c_str(), rsp.attr_value.len);
-            }
+          if (value.length() + 1 > maxOffset)
+          {
+            // Too big for a single shot entry.
+            m_value.setReadOffset(maxOffset);
+            rsp.attr_value.len = maxOffset;
+            rsp.attr_value.offset = 0;
+            memcpy(rsp.attr_value.value, value.c_str(), rsp.attr_value.len);
           }
-          rsp.attr_value.handle = param->read.handle;
-          rsp.attr_value.auth_req = ESP_GATT_AUTH_REQ_NONE;
+          else
+          {
+            // Will fit in a single packet with no callbacks required.
+            rsp.attr_value.len = value.length();
+            rsp.attr_value.offset = 0;
+            memcpy(rsp.attr_value.value, value.c_str(), rsp.attr_value.len);
+          }
+        }
+        rsp.attr_value.handle = param->read.handle;
+        rsp.attr_value.auth_req = ESP_GATT_AUTH_REQ_NONE;
 
-          char *pHexData = BLEUtils::buildHexData(nullptr, rsp.attr_value.value, rsp.attr_value.len);
-          log_d(" - Data: length=%d, data=%s, offset=%d", rsp.attr_value.len, pHexData, rsp.attr_value.offset);
-          free(pHexData);
+        char *pHexData = BLEUtils::buildHexData(nullptr, rsp.attr_value.value, rsp.attr_value.len);
+        log_d(" - Data: length=%d, data=%s, offset=%d", rsp.attr_value.len, pHexData, rsp.attr_value.offset);
+        free(pHexData);
 
-          esp_err_t errRc = ::esp_ble_gatts_send_response(gatts_if, param->read.conn_id, param->read.trans_id, ESP_GATT_OK, &rsp);
-          if (errRc != ESP_OK) {
-            log_e("esp_ble_gatts_send_response: rc=%d %s", errRc, GeneralUtils::errorToString(errRc));
-          }
-        }  // Response needed
-      }  // Handle matches this characteristic.
-      break;
-    }  // ESP_GATTS_READ_EVT
+        esp_err_t errRc = ::esp_ble_gatts_send_response(gatts_if, param->read.conn_id, param->read.trans_id, ESP_GATT_OK, &rsp);
+        if (errRc != ESP_OK)
+        {
+          log_e("esp_ble_gatts_send_response: rc=%d %s", errRc, GeneralUtils::errorToString(errRc));
+        }
+      } // Response needed
+    } // Handle matches this characteristic.
+    break;
+  } // ESP_GATTS_READ_EVT
 
-    // ESP_GATTS_CONF_EVT
-    //
-    // conf:
-    // - esp_gatt_status_t status  – The status code.
-    // - uint16_t          conn_id – The connection used.
-    //
-    case ESP_GATTS_CONF_EVT:
-    {
-      // log_d("m_handle = %d, conf->handle = %d", m_handle, param->conf.handle);
-      if (param->conf.conn_id
-          == getService()->getServer()->getConnId()) {  // && param->conf.handle == m_handle) // bug in esp-idf and not implemented in arduino yet
-        m_semaphoreConfEvt.give(param->conf.status);
-      }
-      break;
+  // ESP_GATTS_CONF_EVT
+  //
+  // conf:
+  // - esp_gatt_status_t status  – The status code.
+  // - uint16_t          conn_id  The connection used.
+  //
+  case ESP_GATTS_CONF_EVT:
+  {
+    // log_d("m_handle = %d, conf->handle = %d", m_handle, param->conf.handle);
+    if (param->conf.conn_id == getService()->getServer()->getConnId())
+    { // && param->conf.handle == m_handle) // bug in esp-idf and not implemented in arduino yet
+      m_semaphoreConfEvt.give(param->conf.status);
     }
+    break;
+  }
 
-    case ESP_GATTS_CONNECT_EVT:
-    {
-      break;
-    }
+  case ESP_GATTS_CONNECT_EVT:
+  {
+    break;
+  }
 
-    case ESP_GATTS_DISCONNECT_EVT:
-    {
-      m_semaphoreConfEvt.give();
-      break;
-    }
+  case ESP_GATTS_DISCONNECT_EVT:
+  {
+    m_semaphoreConfEvt.give();
+    break;
+  }
 
-    default:
-    {
-      break;
-    }  // default
+  default:
+  {
+    break;
+  } // default
 
-  }  // switch event
+  } // switch event
 
   // Give each of the descriptors associated with this characteristic the opportunity to handle the
   // event.
 
   m_descriptorMap.handleGATTServerEvent(event, gatts_if, param);
   log_v("<< handleGATTServerEvent");
-}  // handleGATTServerEvent
+} // handleGATTServerEvent
 
 /**
  * @brief Send an indication.
@@ -450,12 +508,13 @@
  * will block waiting a positive confirmation from the client.
  * @return N/A
  */
-void BLECharacteristic::indicate() {
+void BLECharacteristic::indicate()
+{
 
   log_v(">> indicate: length: %d", m_value.getValue().length());
   notify(false);
   log_v("<< indicate");
-}  // indicate
+} // indicate
 
 /**
  * @brief Send a notify.
@@ -463,17 +522,19 @@
  * will not block; it is a fire and forget.
  * @return N/A.
  */
-void BLECharacteristic::notify(bool is_notification) {
+void BLECharacteristic::notify(bool is_notification)
+{
   log_v(">> notify: length: %d", m_value.getValue().length());
 
   assert(getService() != nullptr);
   assert(getService()->getServer() != nullptr);
 
-  m_pCallbacks->onNotify(this);  // Invoke the notify callback.
+  m_pCallbacks->onNotify(this); // Invoke the notify callback.
 
   GeneralUtils::hexDump((uint8_t *)m_value.getValue().c_str(), m_value.getValue().length());
 
-  if (getService()->getServer()->getConnectedCount() == 0) {
+  if (getService()->getServer()->getConnectedCount() == 0)
+  {
     log_v("<< notify: No connected clients.");
     m_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::ERROR_NO_CLIENT, 0);
     return;
@@ -483,55 +544,72 @@
   // and, if not, prevent the notification.
 
   BLE2902 *p2902 = (BLE2902 *)getDescriptorByUUID((uint16_t)0x2902);
-  if (is_notification) {
-    if (p2902 != nullptr && !p2902->getNotifications()) {
+  if (is_notification)
+  {
+    if (p2902 != nullptr && !p2902->getNotifications())
+    {
       log_v("<< notifications disabled; ignoring");
-      m_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::ERROR_NOTIFY_DISABLED, 0);  // Invoke the notify callback.
+      m_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::ERROR_NOTIFY_DISABLED, 0); // Invoke the notify callback.
       return;
     }
-  } else {
-    if (p2902 != nullptr && !p2902->getIndications()) {
+  }
+  else
+  {
+    if (p2902 != nullptr && !p2902->getIndications())
+    {
       log_v("<< indications disabled; ignoring");
-      m_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::ERROR_INDICATE_DISABLED, 0);  // Invoke the notify callback.
+      m_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::ERROR_INDICATE_DISABLED, 0); // Invoke the notify callback.
       return;
     }
   }
-  for (auto &myPair : getService()->getServer()->getPeerDevices(false)) {
+  for (auto &myPair : getService()->getServer()->getPeerDevices(false))
+  {
     uint16_t _mtu = (myPair.second.mtu);
-    if (m_value.getValue().length() > _mtu - 3) {
+    if (m_value.getValue().length() > _mtu - 3)
+    {
       log_w("- Truncating to %d bytes (maximum notify size)", _mtu - 3);
     }
 
     size_t length = m_value.getValue().length();
-    if (!is_notification) {  // is indication
+    if (!is_notification)
+    { // is indication
       m_semaphoreConfEvt.take("indicate");
     }
     esp_err_t errRc = ::esp_ble_gatts_send_indicate(
-      getService()->getServer()->getGattsIf(), myPair.first, getHandle(), length, (uint8_t *)m_value.getValue().c_str(), !is_notification
-    );  // The need_confirm = false makes this a notify.
-    if (errRc != ESP_OK) {
+        getService()->getServer()->getGattsIf(), myPair.first, getHandle(), length, (uint8_t *)m_value.getValue().c_str(), !is_notification); // The need_confirm = false makes this a notify.
+    if (errRc != ESP_OK)
+    {
       log_e("<< esp_ble_gatts_send_ %s: rc=%d %s", is_notification ? "notify" : "indicate", errRc, GeneralUtils::errorToString(errRc));
       m_semaphoreConfEvt.give();
-      m_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::ERROR_GATT, errRc);  // Invoke the notify callback.
+      m_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::ERROR_GATT, errRc); // Invoke the notify callback.
       return;
     }
-    if (!is_notification) {  // is indication
-      if (!m_semaphoreConfEvt.timedWait("indicate", indicationTimeout)) {
-        m_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::ERROR_INDICATE_TIMEOUT, 0);  // Invoke the notify callback.
-      } else {
+    if (!is_notification)
+    { // is indication
+      if (!m_semaphoreConfEvt.timedWait("indicate", indicationTimeout))
+      {
+        m_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::ERROR_INDICATE_TIMEOUT, 0); // Invoke the notify callback.
+      }
+      else
+      {
         auto code = (esp_gatt_status_t)m_semaphoreConfEvt.value();
-        if (code == ESP_GATT_OK) {
-          m_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::SUCCESS_INDICATE, code);  // Invoke the notify callback.
-        } else {
+        if (code == ESP_GATT_OK)
+        {
+          m_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::SUCCESS_INDICATE, code); // Invoke the notify callback.
+        }
+        else
+        {
           m_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::ERROR_INDICATE_FAILURE, code);
         }
       }
-    } else {
-      m_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::SUCCESS_NOTIFY, 0);  // Invoke the notify callback.
     }
+    else
+    {
+      m_pCallbacks->onStatus(this, BLECharacteristicCallbacks::Status::SUCCESS_NOTIFY, 0); // Invoke the notify callback.
+    }
   }
   log_v("<< notify");
-}  // Notify
+} // Notify
 
 /**
  * @brief Set the permission to broadcast.
@@ -540,28 +618,36 @@
  * @param [in] value The flag value of the property.
  * @return N/A
  */
-void BLECharacteristic::setBroadcastProperty(bool value) {
-  //log_d("setBroadcastProperty(%d)", value);
-  if (value) {
+void BLECharacteristic::setBroadcastProperty(bool value)
+{
+  // log_d("setBroadcastProperty(%d)", value);
+  if (value)
+  {
     m_properties = (esp_gatt_char_prop_t)(m_properties | ESP_GATT_CHAR_PROP_BIT_BROADCAST);
-  } else {
+  }
+  else
+  {
     m_properties = (esp_gatt_char_prop_t)(m_properties & ~ESP_GATT_CHAR_PROP_BIT_BROADCAST);
   }
-}  // setBroadcastProperty
+} // setBroadcastProperty
 
 /**
  * @brief Set the callback handlers for this characteristic.
  * @param [in] pCallbacks An instance of a callbacks structure used to define any callbacks for the characteristic.
  */
-void BLECharacteristic::setCallbacks(BLECharacteristicCallbacks *pCallbacks) {
+void BLECharacteristic::setCallbacks(BLECharacteristicCallbacks *pCallbacks)
+{
   log_v(">> setCallbacks: 0x%x", (uint32_t)pCallbacks);
-  if (pCallbacks != nullptr) {
+  if (pCallbacks != nullptr)
+  {
     m_pCallbacks = pCallbacks;
-  } else {
+  }
+  else
+  {
     m_pCallbacks = &defaultCallback;
   }
   log_v("<< setCallbacks");
-}  // setCallbacks
+} // setCallbacks
 
 /**
  * @brief Set the BLE handle associated with this characteristic.
@@ -573,61 +659,76 @@
  * that will be propagated down to it which contain a handle value and now know that the event is destined for it.
  * @param [in] handle The handle associated with this characteristic.
  */
-void BLECharacteristic::setHandle(uint16_t handle) {
+void BLECharacteristic::setHandle(uint16_t handle)
+{
   log_v(">> setHandle: handle=0x%.2x, characteristic uuid=%s", handle, getUUID().toString().c_str());
   m_handle = handle;
   log_v("<< setHandle");
-}  // setHandle
+} // setHandle
 
 /**
  * @brief Set the Indicate property value.
  * @param [in] value Set to true if we are to allow indicate messages.
  */
-void BLECharacteristic::setIndicateProperty(bool value) {
-  //log_d("setIndicateProperty(%d)", value);
-  if (value) {
+void BLECharacteristic::setIndicateProperty(bool value)
+{
+  // log_d("setIndicateProperty(%d)", value);
+  if (value)
+  {
     m_properties = (esp_gatt_char_prop_t)(m_properties | ESP_GATT_CHAR_PROP_BIT_INDICATE);
-  } else {
+  }
+  else
+  {
     m_properties = (esp_gatt_char_prop_t)(m_properties & ~ESP_GATT_CHAR_PROP_BIT_INDICATE);
   }
-}  // setIndicateProperty
+} // setIndicateProperty
 
 /**
  * @brief Set the Notify property value.
  * @param [in] value Set to true if we are to allow notification messages.
  */
-void BLECharacteristic::setNotifyProperty(bool value) {
-  //log_d("setNotifyProperty(%d)", value);
-  if (value) {
+void BLECharacteristic::setNotifyProperty(bool value)
+{
+  // log_d("setNotifyProperty(%d)", value);
+  if (value)
+  {
     m_properties = (esp_gatt_char_prop_t)(m_properties | ESP_GATT_CHAR_PROP_BIT_NOTIFY);
-  } else {
+  }
+  else
+  {
     m_properties = (esp_gatt_char_prop_t)(m_properties & ~ESP_GATT_CHAR_PROP_BIT_NOTIFY);
   }
-}  // setNotifyProperty
+} // setNotifyProperty
 
 /**
  * @brief Set the Read property value.
  * @param [in] value Set to true if we are to allow reads.
  */
-void BLECharacteristic::setReadProperty(bool value) {
-  //log_d("setReadProperty(%d)", value);
-  if (value) {
+void BLECharacteristic::setReadProperty(bool value)
+{
+  // log_d("setReadProperty(%d)", value);
+  if (value)
+  {
     m_properties = (esp_gatt_char_prop_t)(m_properties | ESP_GATT_CHAR_PROP_BIT_READ);
-  } else {
+  }
+  else
+  {
     m_properties = (esp_gatt_char_prop_t)(m_properties & ~ESP_GATT_CHAR_PROP_BIT_READ);
   }
-}  // setReadProperty
+} // setReadProperty
 
 /**
  * @brief Set the value of the characteristic.
  * @param [in] data The data to set for the characteristic.
  * @param [in] length The length of the data in bytes.
  */
-void BLECharacteristic::setValue(uint8_t *data, size_t length) {
+void BLECharacteristic::setValue(uint8_t *data, size_t length)
+{
   char *pHex = BLEUtils::buildHexData(nullptr, data, length);
   log_v(">> setValue: length=%d, data=%s, characteristic UUID=%s", length, pHex, getUUID().toString().c_str());
   free(pHex);
-  if (length > ESP_GATT_MAX_ATTR_LEN) {
+  if (length > ESP_GATT_MAX_ATTR_LEN)
+  {
     log_e("Size %d too large, must be no bigger than %d", length, ESP_GATT_MAX_ATTR_LEN);
     return;
   }
@@ -635,7 +736,7 @@
   m_value.setValue(data, length);
   m_semaphoreSetValue.give();
   log_v("<< setValue");
-}  // setValue
+} // setValue
 
 /**
  * @brief Set the value of the characteristic from string data.
@@ -644,131 +745,158 @@
  * @param [in] Set the value of the characteristic.
  * @return N/A.
  */
-void BLECharacteristic::setValue(String value) {
+void BLECharacteristic::setValue(String value)
+{
   setValue((uint8_t *)(value.c_str()), value.length());
-}  // setValue
+} // setValue
 
-void BLECharacteristic::setValue(uint16_t &data16) {
+void BLECharacteristic::setValue(uint16_t &data16)
+{
   uint8_t temp[2];
   temp[0] = data16;
   temp[1] = data16 >> 8;
   setValue(temp, 2);
-}  // setValue
+} // setValue
 
-void BLECharacteristic::setValue(uint32_t &data32) {
+void BLECharacteristic::setValue(uint32_t &data32)
+{
   uint8_t temp[4];
   temp[0] = data32;
   temp[1] = data32 >> 8;
   temp[2] = data32 >> 16;
   temp[3] = data32 >> 24;
   setValue(temp, 4);
-}  // setValue
+} // setValue
 
-void BLECharacteristic::setValue(int &data32) {
+void BLECharacteristic::setValue(int &data32)
+{
   uint8_t temp[4];
   temp[0] = data32;
   temp[1] = data32 >> 8;
   temp[2] = data32 >> 16;
   temp[3] = data32 >> 24;
   setValue(temp, 4);
-}  // setValue
+} // setValue
 
-void BLECharacteristic::setValue(float &data32) {
+void BLECharacteristic::setValue(float &data32)
+{
   float temp = data32;
   setValue((uint8_t *)&temp, 4);
-}  // setValue
+} // setValue
 
-void BLECharacteristic::setValue(double &data64) {
+void BLECharacteristic::setValue(double &data64)
+{
   double temp = data64;
   setValue((uint8_t *)&temp, 8);
-}  // setValue
+} // setValue
 
 /**
  * @brief Set the Write No Response property value.
  * @param [in] value Set to true if we are to allow writes with no response.
  */
-void BLECharacteristic::setWriteNoResponseProperty(bool value) {
-  //log_d("setWriteNoResponseProperty(%d)", value);
-  if (value) {
+void BLECharacteristic::setWriteNoResponseProperty(bool value)
+{
+  // log_d("setWriteNoResponseProperty(%d)", value);
+  if (value)
+  {
     m_properties = (esp_gatt_char_prop_t)(m_properties | ESP_GATT_CHAR_PROP_BIT_WRITE_NR);
-  } else {
+  }
+  else
+  {
     m_properties = (esp_gatt_char_prop_t)(m_properties & ~ESP_GATT_CHAR_PROP_BIT_WRITE_NR);
   }
-}  // setWriteNoResponseProperty
+} // setWriteNoResponseProperty
 
 /**
  * @brief Set the Write property value.
  * @param [in] value Set to true if we are to allow writes.
  */
-void BLECharacteristic::setWriteProperty(bool value) {
-  //log_d("setWriteProperty(%d)", value);
-  if (value) {
+void BLECharacteristic::setWriteProperty(bool value)
+{
+  // log_d("setWriteProperty(%d)", value);
+  if (value)
+  {
     m_properties = (esp_gatt_char_prop_t)(m_properties | ESP_GATT_CHAR_PROP_BIT_WRITE);
-  } else {
+  }
+  else
+  {
     m_properties = (esp_gatt_char_prop_t)(m_properties & ~ESP_GATT_CHAR_PROP_BIT_WRITE);
   }
-}  // setWriteProperty
+} // setWriteProperty
 
 /**
  * @brief Return a string representation of the characteristic.
  * @return A string representation of the characteristic.
  */
-String BLECharacteristic::toString() {
+String BLECharacteristic::toString()
+{
   String res = "UUID: " + m_bleUUID.toString() + ", handle : 0x";
   char hex[5];
   snprintf(hex, sizeof(hex), "%04x", m_handle);
   res += hex;
   res += " ";
-  if (m_properties & ESP_GATT_CHAR_PROP_BIT_READ) {
+  if (m_properties & ESP_GATT_CHAR_PROP_BIT_READ)
+  {
     res += "Read ";
   }
-  if (m_properties & ESP_GATT_CHAR_PROP_BIT_WRITE) {
+  if (m_properties & ESP_GATT_CHAR_PROP_BIT_WRITE)
+  {
     res += "Write ";
   }
-  if (m_properties & ESP_GATT_CHAR_PROP_BIT_WRITE_NR) {
+  if (m_properties & ESP_GATT_CHAR_PROP_BIT_WRITE_NR)
+  {
     res += "WriteNoResponse ";
   }
-  if (m_properties & ESP_GATT_CHAR_PROP_BIT_BROADCAST) {
+  if (m_properties & ESP_GATT_CHAR_PROP_BIT_BROADCAST)
+  {
     res += "Broadcast ";
   }
-  if (m_properties & ESP_GATT_CHAR_PROP_BIT_NOTIFY) {
+  if (m_properties & ESP_GATT_CHAR_PROP_BIT_NOTIFY)
+  {
     res += "Notify ";
   }
-  if (m_properties & ESP_GATT_CHAR_PROP_BIT_INDICATE) {
+  if (m_properties & ESP_GATT_CHAR_PROP_BIT_INDICATE)
+  {
     res += "Indicate ";
   }
   return res;
-}  // toString
+} // toString
 
 BLECharacteristicCallbacks::~BLECharacteristicCallbacks() {}
 
-void BLECharacteristicCallbacks::onRead(BLECharacteristic *pCharacteristic, esp_ble_gatts_cb_param_t *param) {
+void BLECharacteristicCallbacks::onRead(BLECharacteristic *pCharacteristic, esp_ble_gatts_cb_param_t *param)
+{
   onRead(pCharacteristic);
-}  // onRead
+} // onRead
 
-void BLECharacteristicCallbacks::onRead(BLECharacteristic *pCharacteristic) {
+void BLECharacteristicCallbacks::onRead(BLECharacteristic *pCharacteristic)
+{
   log_d(">> onRead: default");
   log_d("<< onRead");
-}  // onRead
+} // onRead
 
-void BLECharacteristicCallbacks::onWrite(BLECharacteristic *pCharacteristic, esp_ble_gatts_cb_param_t *param) {
+void BLECharacteristicCallbacks::onWrite(BLECharacteristic *pCharacteristic, esp_ble_gatts_cb_param_t *param)
+{
   onWrite(pCharacteristic);
-}  // onWrite
+} // onWrite
 
-void BLECharacteristicCallbacks::onWrite(BLECharacteristic *pCharacteristic) {
+void BLECharacteristicCallbacks::onWrite(BLECharacteristic *pCharacteristic)
+{
   log_d(">> onWrite: default");
   log_d("<< onWrite");
-}  // onWrite
+} // onWrite
 
-void BLECharacteristicCallbacks::onNotify(BLECharacteristic *pCharacteristic) {
+void BLECharacteristicCallbacks::onNotify(BLECharacteristic *pCharacteristic)
+{
   log_d(">> onNotify: default");
   log_d("<< onNotify");
-}  // onNotify
+} // onNotify
 
-void BLECharacteristicCallbacks::onStatus(BLECharacteristic *pCharacteristic, Status s, uint32_t code) {
+void BLECharacteristicCallbacks::onStatus(BLECharacteristic *pCharacteristic, Status s, uint32_t code)
+{
   log_d(">> onStatus: default");
   log_d("<< onStatus");
-}  // onStatus
+} // onStatus
 
 #endif /* CONFIG_BLUEDROID_ENABLED */
 #endif /* SOC_BLE_SUPPORTED */
